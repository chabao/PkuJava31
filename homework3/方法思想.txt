1.isWon(int posX, int posY, String ico)

    对于位置（posX,posY）来说，扫描该位置四个方向的情况，即横向，纵向，斜上，斜下。每个方向的扫描情况有范围，比如横向的范围就是从（max(posX-4,0)，posY）到（min(posX+4)，posY），扫描的时候从（posX,posY）开始向（max(posX-4,0)，posY）扫描，直到找到第一个和ico不相同的点或者边界停止，接着从（posX,posY）开始向（min(posX+4)，posY）扫描，直到找到第一个和ico不相同的点或者边界停止。如果两个点的X坐标相减为6，则证明有五连子，游戏结束。
    其他三种情况与此相同，就不一一赘述。

2.computerDo()

    此方法实现电脑较为智能地下棋。
    我用整形二维数组保存棋盘所有位置的权值，电脑下棋的时候，扫描整个数组，找到权值最大的位置。这个位置就是电脑当前要下棋的位置。

(1)权值设定
    因为电脑需要攻守兼备，所以一个位置四个方向的紧邻位置出现电脑连子或者玩家连子的情况，权值都	 	 要增加，连子数越多，则权值越重。同样连子数的情况下，攻优先于守。所以同样连子数的情况下，电脑连子数的权值大于玩家，设定为两倍。
	  w1=100 000,出现电脑四连子的权值；   w2=50 000,出现玩家四连子的权值；
  	  w3=10 000,出现电脑三连子的权值；    w4=5000,出现玩家三连子的权值
	  w5=1000,出现电脑二连子的权值；      w6=500,出现玩家二连子的权值
	  w6=100,出现电脑一连子的权值；       w8=50，出现玩家一连子的权值

(2)一个位置的权值计算------weightCal(int x,int y)
    该位置的权值为四个方向上的权值总和。每个方向的权值由该方向的连子数和棋子种类决定。沿某个方向扫描时，从该位置出发扫描两侧，计算该位置两侧指定种类的棋子的连子数,以较大者作为该方向的连子数。
	